# 第2章 信息的处理和表示

## C 语言数据类型大小

`long` 和指针类型在 32 位和 64 位上分别是 4 字节和 8 字节，其它数据类型在两个平台上相同。

## 字节序

对于 0x100 地址处的十六进制数 0x01234567，大端存储：

| 内存地址 | ... | 0x100 | 0x101 | 0x102 | 0x103 | ... |
| --- | --- | --- | --- | --- | --- | --- |
| 值 |  | 01 | 23 | 45 | 67 |  |

小端存储：

| 内存地址 | ... | 0x100 | 0x101 | 0x102 | 0x103 | ... |
| --- | --- | --- | --- | --- | --- | --- |
| 值 |  | 67 | 45 | 23 | 01 |  |

注意内存地址的顺序，并且整个数据的地址始终是各字节地址最小者。

## 位运算

异或运算的性质：`a ^ a = 0`、`a ^ a ^ b = b`、`x ^ y == (x & ~y) | (~x & y)`。

左移：右端补 0；逻辑右移：左端补 0；算数右移：左端补最高有效位。

## 整数

C 语言标准中，除了固定大小的数据类型（如 `int32_t`）之外，只要求正负数对称的取值范围，比如 `char` 只要求 -127 到 127，但在实现中几乎全都是 -128 到 127（补码表示）。

补码定义：对位向量 $x = [x_{w-1}, x_{w-2}, \cdots, x_0]$，$B2T_w(x) = - x_{w-1} \cdot 2^{w-1} + \sum\limits_{i=0}^{w-2} x_i \cdot 2^i$。

整数的强制类型转换保持位模式不变，数值可能会改变。

补码转无符号：$T2U_w(x) = \begin{cases} x + 2^w, & x < 0 \\ x, & x \ge 0 \end{cases} = x + x_{w-1} \cdot 2^w$。

无符号转补码：$U2T_w(u) = \begin{cases} u, & u \le TMax_w \\ u - 2^w, & u > TMax_w \end{cases} = - u_{w-1} \cdot 2^w + u$。

当执行一个运算时，如果一个运算数是有符号的而另一个是无符号的，C 语言会隐式地将有符号数强制类型转换为无符号数，并假设两个数都是非负的，来执行这个运算。

扩展数字的位表示：无符号数——零扩展，补码——符号扩展。

截断数字：总是舍弃位模式中的高位，保留低位，然后再转回无符号数或补码。

求补码加法逆元的方法：按位取反再加一。

补码加法运算形成阿贝尔群，可交换可结合，故 `x + y - x == y`、`x + y - y == x`。

无符号数乘法和补码乘法在位级别等价。

## 值得注意的题目

P65-2.31-2.32
