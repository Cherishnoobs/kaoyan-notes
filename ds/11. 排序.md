# 排序

## 冒泡排序

```cpp
template <typename T>
void bubble_sort(vector<T> &vec) {
    auto len = vec.size();
    for (int i = 0; i < len - 1; i++) {
        for (int j = 0; j < len - 1 - i; j++) {
            if (vec[j] > vec[j + 1]) {
                swap(vec[j], vec[j + 1]);
            }
        }
    }
}
```

左侧无序，右侧有序，不断将左侧最大者冒泡到右侧。由于交换条件是 `vec[j] > vec[j + 1]`，当有重复元素时，顺序会被保持，因此是稳定的。

## 归并排序

```cpp
template <typename T>
void merge_sort(vector<T> &vec) {
    _merge_sort(vec, 0, vec.size());
}

template <typename T>
void _merge_sort(vector<T> &vec, int lo, int hi) {
    if (hi - lo < 2) return; // recursion base: single element
    int mi = (hi + lo) / 2;
    _merge_sort(vec, lo, mi); // sort [lo, mi);
    _merge_sort(vec, mi, hi); // sort [mi, hi);
    _merge(vec, lo, mi, hi);
}

template <typename T>
void _merge(vector<T> &vec, int lo, int mi, int hi) {
    vector<T> leftvec(mi - lo); // temp vector to store the left part
    for (int i = 0; i < mi - lo; i++) leftvec[i] = vec[lo + i]; // copy left part

    int i = lo, j = mi, k = lo;
    while (i < mi && j < hi) {
        if (leftvec[i - lo] <= vec[j]) {
            vec[k++] = leftvec[(i++) - lo];
        } else {
            vec[k++] = vec[j++];
        }
    }
    while (i < mi) vec[k++] = leftvec[(i++) - lo];
    while (j < hi) vec[k++] = vec[j++];
}
```

不断二分递归，然后归并。归并时优先选择左侧，故是稳定的。

## 插入排序

```cpp
template <typename T>
void insertion_sort(list<T> &lst) {
    auto it = lst.begin();
    while (it != lst.end()) {
        auto val = *it;
        auto pos = find_if(lst.begin(), it, [&](auto x) { return val < x; });
        lst.insert(pos, val);
        auto last = it++;
        lst.erase(last);
    }
}
```

左侧有序，右侧无序，不断把右侧第一个元素插入到左侧适当位置。查找适当位置的判断条件 `val < x` 保证原序列中靠右的元素被插入到靠右的位置，故是稳定的。

## 选择排序

### 交换版（适用于数组和链表）

```cpp
template <typename T>
void selection_sort(list<T> &lst) {
    auto unsorted_end = lst.end();
    while (unsorted_end != lst.begin()) {
        auto max_pos = _select_max(lst.begin(), unsorted_end);
        --unsorted_end;
        swap(*max_pos, *unsorted_end);
    }
}

template <typename Iter>
Iter _select_max(Iter begin, Iter end) {
    auto max_pos = begin;
    for (auto sel_it = begin; sel_it != end; ++sel_it) {
        max_pos = *sel_it >= *max_pos ? sel_it : max_pos;
    }
    return max_pos;
}
```

左侧无序，右侧有序，不断选择左侧最大元素，与左侧最尾元素交换。由于每次将左侧最尾元素交换到左侧中间位置，会导致重复元素位置变化，故是不稳定的。

也可以左侧有序，右侧无序，不断选择右侧最小元素，与右侧最首元素交换。

### 插入版（适用于链表）

```cpp
template <typename T>
void selection_sort(list<T> &lst) {
    auto unsorted_begin = lst.begin();
    while (unsorted_begin != lst.end()) {
        auto max_pos = _select_max(unsorted_begin, lst.end());
        lst.insert(lst.begin(), *max_pos);
        if (max_pos == unsorted_begin) ++unsorted_begin;
        lst.erase(max_pos);
    }
}

template <typename Iter>
Iter _select_max(Iter begin, Iter end) {
    auto max_pos = begin;
    for (auto sel_it = begin; sel_it != end; ++sel_it) {
        max_pos = *sel_it >= *max_pos ? sel_it : max_pos;
    }
    return max_pos;
}
```

左侧有序，右侧无序，不断选择右侧最大者，插入到左侧开头。选择最大者时，`*sel_it >= *max_pos` 保证了每次选择到相同元素的最右者，且不会将某个边界元素交换到中间，故是稳定的。

也可以左侧无序，右侧有序，不断选择左侧最大者，插入到右侧的开头。

## 桶排序

```cpp
void bucket_sort(vector<int> &vec) {
    auto minmax_elem = minmax_element(vec.begin(), vec.end());
    auto min_elem = *minmax_elem.first, max_elem = *minmax_elem.second;
    auto offset = -min_elem;
    vector<int> bucket(max_elem + offset + 1);
    for (const auto &x : vec) bucket[x + offset]++;
    vec.clear();
    for (auto x = 0; x < bucket.size(); x++) {
        for (auto j = 0; j < bucket[x]; j++) {
            vec.push_back(x - offset);
        }
    }
}
```

把 `bucket` 的元素类型改为待排序对象的链表，即可实现稳定性。

## 基数排序

用于排序有多个域组成的关键码（例如元组、字符串），从低位到高位（例如字符串从右向左）分别进行一次桶排序。

这里的核心在于，低位排序之后，再对高位排序时，若遇到相同元素，则需要保持先前的低位顺序不变，也就是说基数排序是依赖于桶排序的稳定性的。基数排序本身也是稳定的。

## 堆排序

```cpp
template <typename T>
void heap_sort(vector<T> &vec) {
    make_heap(vec.begin(), vec.end());
    for (int n = vec.size(); n > 0; n--) {
        auto min_elem = vec[0];
        pop_heap(vec.begin(), vec.begin() + n);
        vec[n - 1] = min_elem;
    }
}
```

## 快速排序

```cpp
template <typename T>
void quick_sort(vector<T> &vec) {
    random_shuffle(vec.begin(), vec.end()); // shuffle to avoid the worst case
    _quick_sort(vec, 0, vec.size());
}

template <typename T>
void _quick_sort(vector<T> &vec, int lo, int hi) { // sort [lo, hi)
    if (hi - lo < 2) return;
    int mi = _partition(vec, lo, hi - 1); // vec[mi] is the pivot, which is in the right position
    _quick_sort(vec, lo, mi); // sort [lo, mi)
    _quick_sort(vec, mi + 1, hi); // sort (mi, hi)
}

template <typename T>
int _partition(vector<T> &vec, int lo, int hi) { // partition [lo, hi]
    T pivot = vec[lo];
    while (lo < hi) {
        while (lo < hi && vec[hi] >= pivot) hi--;
        vec[lo] = vec[hi];
        while (lo < hi && vec[lo] <= pivot) lo++;
        vec[hi] = vec[lo];
    }
    vec[lo] = pivot;
    return lo;
}
```

取待排序区间的第一个元素为轴点（pivot），对区间进行快速划分（quick partitioning）——将小于等于轴点的元素移到左边、大于等于轴点的元素移到右边，然后将轴点放到中间正确的位置，接着分别对左半边和右半边进行同样的操作。

## 总结

| 名称 | 复杂度 | 原地 | 稳定 | 适用情况 |
| --- | --- | --- | --- | --- |
| 冒泡排序 |
| 归并排序 |
| 插入排序 |
| 选择排序 |
| 桶排序 |
| 基数排序 |
| 堆排序 |
| 快速排序 |
